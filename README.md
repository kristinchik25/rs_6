# rs_6
# Лабораторная работа 6. Проектирование и реализация комплексной микросервисной системы для автоматизации бизнес-процесса с использованием Docker Compose
# Цель
научиться разворачивать многокомпонентные приложения, понимать взаимодействие между контейнерами (Business Logic + Database) и модифицировать параметры системы под конкретные бизнес-задачи.
# Дамдинова Кристина, АБП-231, вариант 12
## Описание проекта
Проект представляет собой микросервисное веб-приложение для подсчета голосов с использованием Flask и Redis. Особенностью варианта 12 является реализация темы "Голосование", где на странице отображается текст: «Голосов за кандидата А: X», а счетчик голосов автоматически увеличивается на 1 при каждом новом входе на страницу.
## Бизнес-кейс "Голосование"
Проходит голосование, чтобы поддержать кандидата А, необходимо перейти по ссылке.Система ведёт учёт голосов, а каждое посещение пользователем веб-страницы приводит к увеличению счётчика голосов на 1. Результат отображается в виде сообщения: «Голосов за кандидата А: X».
## Архитектура
Система построена на микросервисной архитектуре с использованием Docker Compose для оркестрации контейнеров.

<img width="988" height="602" alt="image" src="https://github.com/user-attachments/assets/e57725ff-ad30-4c8c-bafe-42e50890c73b" />
 

## Компоненты системы
### Web Service (Flask):
- Принимает HTTP-запросы от пользователей и отдаёт HTML-страницу.​
- Реализует бизнес-логику: при каждом заходе на страницы выполняется увеличение счётчика голосов на 1​
- Подключается к Redis и отображает текущий результат в виде текста: «Голосов за кандидата А: X» в интерфейсе системы голосования

### Redis Service:
- Хранит текущее значение счётчика голосов в памяти​
- Обеспечивает быстрый доступ к данным​
- Настроен с политикой restart: always для высокой доступности

### Docker Compose:
- Оркестрирует запуск сервисов
- Управляет сетевой связностью между контейнерами
- Обеспечивает зависимость web от redis

## Стек технологий
### Backend
* Python 3.9 — язык программирования
* Flask 2.0.1 — веб-фреймворк
* Redis 4.6.0 — клиент для взаимодействия с хранилищем
  
### Инфраструктура и DevOps
* Docker — контейнеризация приложений
* Docker Compose 3.9 — оркестрация многоконтейнерных приложений
* Alpine Linux — легковесный базовый образ
  
### Сетевые протоколы
* HTTP/1.1 — для клиент-серверного взаимодействия
* Redis Protocol — для взаимодействия Flask ↔ Redis


# Внесенные изменения, вариант 12
### 1. Бизнес-логика (app.py)
- Счётчик голосов увеличивается на 1 при каждом обращении
- "Голосов за кандидата А: X"
  
### 2. Инфраструктура (docker-compose.yml)
- Добавлена зависимость depends_on
- Добавлена политика перезапуска restart: always для сервиса Redis

### 3. Среда сборки (Dockerfile)
- Добавлен LABEL version="1.0".


### Предварительные требования
* Docker Engine установлен и запущен
* Docker Compose V2 доступен (docker compose)

## Ход работы
### 1. Создаю папку проекта, в которой будем работать и заходим в нее
```
mkdir lab6_business && cd lab6_business
```
### 2. Создаем файл зависимостей (requirements.txt) с библиотеками:
```
nano requirements.txt
```
Его наполнение:
```
Flask==2.0.1
Werkzeug==2.3.7
redis==4.6.0
```
Для сохранения и выхода использовать сочетание клавиш Ctrl+c +Y +Enter
### 3. Создаем файл бизнес-логики (app.py):
```
nano app.py
```
В него вставляем уже отредактированный файл в соотвествии с индивидуальным заданием:
```
import time
import redis
from flask import Flask

app = Flask(__name__)

cache = redis.Redis(host='redis', port=6379)

def get_vote_count():
    retries = 5
    while True:
        try:
            return cache.incr('votes')
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)

@app.route('/')
def hello():
    count = get_vote_count()
    return '<h1 style="color:blue">Система голосования</h1><p>Голосов за кандидата А: <strong>{}</strong></p>'.format(count)

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
```
### 4. Создаем инструкцию по сборке образа (Dockerfile):
```
nano Dockerfile
```
Наполнение файла:
```
FROM python:3.9-alpine
# Добавляем метку версии
LABEL version="1.0"
WORKDIR /code
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]
```
### 5. Создаем файл связки сервисов (docker-compose.yml):
```
nano docker-compose.yml
```
Заполняем следующим:
```
version: "3.9"
services:
  web:
    build: .
    ports:
      - "8000:5000"
    depends_on:
      - redis

  redis:
    image: "redis:alpine"
    restart: always
```
### 6. Запуск и проверка
```
docker compose up -d
```
<img width="634" height="480" alt="image" src="https://github.com/user-attachments/assets/04f328b1-8f5f-4300-b358-f5bca515f43b" />

```
docker compose ps
```

<img width="624" height="345" alt="image" src="https://github.com/user-attachments/assets/9f976678-c906-4eaa-b46d-576627c5b7ca" />

Status в состоянии Up, следовательно, контейнеры запущены. Далее открываем браузер по адресу http://localhost:8000

<img width="810" height="352" alt="image" src="https://github.com/user-attachments/assets/070a1cad-b90f-4600-a59e-a243d8b8359d" />

Сервер работает, проверим идет ли счетчик при новом заходе на страницу

<img width="825" height="588" alt="image" src="https://github.com/user-attachments/assets/db331bdf-8526-4fd6-b5f6-4ab5f5971dc3" />

Задание выполнено в полном объеме, сайт функционирует в соотвествии с требованиями.
# Вывод
В ходе лабораторной работы было освоено развёртывание многокомпонентных приложений, анализ взаимодействия контейнеров и настройка параметров системы под конкретные бизнес-задачи.
